代码

flush flush中, histgram 是可以直接跑的,sc文件夹都需要设置参数, 知道cache的各个参数, aes还需要openssl库. 学姐已经完成了.  write buffer学姐也加了.

然后eviction set , 难点也是不同的cpu  cache line等参数不一样, 每个都有变化.  



论文

## Introduction

- 很快, 范围大, flush reload做不到但是她可以做到

## Background

- CPU Caches  . last level缓存被划分为与内核一样多的slices，并通过环形总线互连。unprivileged clflush指令将所有cache层次结构中的cache line逐出。 但是，程序也可以通过accessing enough memory来evict cache line

- Shared Memory操作系统和虚拟机管理程序使用共享内存来减少整体物理内存利用率和TLB利用率。 共享库仅一次加载到物理内存中，并由使用它们的所有程序共享。 因此，多个程序访问在其自己的虚拟地址空间内映射的相同物理页面。操作系统类似地优化文件映射，分叉进程，两次启动进程或使用mmap或dlopen。 所有情况都会导致与映射同一文件的所有其他进程共享一个内存区域。 在个人计算机，智能手机，私有云系统上，甚至在公共云中[1]，都可以找到另一种形式的共享内存，即基于内容的页面重复数据删除。 系统管理程序或操作系统会扫描物理内存中的字节相同页面。 相同的页面将重新映射到同一物理页面，而另一页面则标记为空闲。 此技术可以显着降低物理内存和TLB的使用。 但是，在完全不相关且可能是沙盒化的进程之间以及在不同虚拟机中运行的进程之间共享内存带来了安全性和隐私问题。

- Cache Attacks and Rowhammer:   在Prime + Probe攻击中，攻击者占用一个缓存集，并在受害者替换该缓存集中的任何行时进行测量。 现代处理器具有物理索引的最后一级缓存，使用复杂的地址和未记录的替换策略。 去年提出了应对这些挑战的跨VM侧通道攻击[16，24]和隐蔽通道[28]。 Oren等。 [29]显示，Prime + Probe缓存攻击可以从浏览器中的沙盒JavaScript中发起，从而使远程攻击者可以窃听网络流量统计信息或通过网站进行的鼠标移动。                                                                        Flush + Reload是在单个缓存行上起作用的两阶段攻击。 首先，它使用clflush指令刷新高速缓存行，然后测量重新加载数据所需的时间。 根据时间测量，攻击者同时确定目标地址是否已被另一个进程重新加载。 与Prime + Probe相比，Flush + Reload利用共享内存的可用性，尤其是攻击者与受害者程序之间的共享库。 Flush + Reload的应用已被证明是可靠且强大的，主要用于攻击密码算法[12、17、18、48]。

  Rowhammer不是典型的缓存攻击，而是DRAM漏洞，该漏洞通过重复访问DRAM行而导致随机位翻转[20]。 但是，它与缓存攻击有一些相似之处，因为访问必须绕过所有级别的缓存才能到达DRAM并触发位翻转。 已经证明利用此漏洞的攻击可以获得root特权并逃避了沙箱[36]。 这是怎么做到的也太强了! Rowhammer导致大量的高速缓存命中和高速缓存未命中，类似于高速缓存攻击。

## Flush + Flush attack 

-  我们的攻击建立在观察到clflush指令可以在高速缓存未命中的情况下提前中止的基础之上。 如果发生高速缓存命中，则必须在所有本地高速缓存上触发逐出。 可以以缓存攻击的形式利用此时序差异，但由于每个内核可以比其他内核更快地访问其自己的cache slices，因此它也可以用于派生有关缓存片和CPU内核的信息。攻击仅包含一个阶段，该阶段以无限循环执行。 它是在目标共享内存行上执行clflush指令。攻击者测量clflush指令的执行时间。 攻击者根据执行时间确定存储行是否已缓存。 由于攻击者没有将内存行加载到高速缓存中，因此这表明是否有其他进程已将其加载。 同时，clflush将缓存中的内存行逐出，以进行下一轮攻击。 使用提供亚纳秒分辨率时间戳的rdtsc指令完成测量。 它还使用mfence指令，因为clflush仅通过mfence进行排序，而不能通过任何其他方式进行排序。

- 图1显示了clflush指令对缓存和非缓存内存行的执行时间直方 . 如果地址映射到远程核心，则对高速缓存命中的最短执行时间增加3个周期的惩罚。 差异足以使攻击者观察到。 我们将在9.1节中讨论这种时序差异及其含义。 在任何一种情况下，执行时间均小于最后一级缓存中缓存的内存和未缓存的内存访问的访问时间。 因此，Flush + Flush的速度明显快于其他任何最后一级的缓存攻击。在某些情况下，由于击中和未击中之间的时间差较小，并且由于平均访问时间较短，因此Flush + Flush攻击固有地具有比Flush + Reload技术稍低的准确性。 但是，由于执行时间明显缩短，因此使用Flush + Flush攻击可以更快地提取相同数量的信息。 

- 此外，Flush + Reload攻击的重载步骤可能会触发预取器，从而通过将数据取入缓存来破坏测量。 尤其是在监视物理页面[10]中的多个地址时，尤其是这种情况。 由于Flush + Flush攻击从不执行任何内存访问，因此不存在此问题，并且Flush + Flush攻击在此处实现了更高的准确性。 出于相同的原因，“刷新+刷新”攻击不会导致任何高速缓存未命中，并且只会导致极少数的高速缓存命中。 因此，最近提出的使用缓存引用和缓存未命中的检测机制无法检测Flush + Flush。

  ## how to leverage hardware performance counters to detect cache attacks

- 

- a covert channel

- a side-channel attack on keystroke timings

- cryptographic algorithms

- implications and countermeasures.

- related work.

- conclusion