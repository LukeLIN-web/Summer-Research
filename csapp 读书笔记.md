# csapp 读书笔记

# 第一章 

## 1.7 

每个进程看到的虚拟区如下:

内核虚拟存储器

栈(往下)

...

共享库

...

堆 (往上)

只读的 程序代码和数据



多核处理器:  独立的 L1, L2 ,  共享L3   

超线程:

 让一个核执行两个线程,常规处理器要用20000 个cycle 来做线程转换,而超线程可以用一个周期.



# 第二章

## 2.1

typedef int * int_pointer 可以让可读性好很多.





# 第三章程序的机器级表示

## 3.11

gdb , 命令行, 很多程序员会用ddd,  是gdb的拓展, 提供了图形化界面

所有的gnu包使用 -o2 优化编译的, 常常用循环来替代递归.这显著提高了程序的性能, 但是让源代码和机器代码的映射更加难以辨别, 难以调试. 



#### 缓冲区溢出攻击

1. 用一个指向攻击代码的指针覆盖返回地址, 执行ret的指令的效果就是跳转到攻击代码.

2. 使用系统调用启动一个shell, 给攻击者提供一个操作系统函数. 
3. 攻击代码会执行一些未授权的任务, 然后修复对栈的破坏, 然后第二次执行ret指令. 表面上正常返回.



#### 对抗 缓冲区溢出攻击

1. 栈随机化

如果攻击者确定一个常见的web服务器的栈空间, 就可以设计一个在许多机器上都能实施的攻击,  这叫安全单一化  .security monoculture

随机化的方法, 一个是随机malloc 一个空间, 让后面栈的位置都变化, 

Linux中栈随机化已经是标准行为, 是地址空间布局随机化的一种  address -space layout randomization.

有的攻击者会用 nop sled 反复用不同地址枚举来攻击, 

2. 栈破坏检测

 新版gcc 在栈帧中存储一个随机产生的canary 值, 也叫guard value , 在恢复寄存器状态和从函数返回之前检测, 如果被改变了, 程序异常中止.

3. 限制可执行代码区域

引入 no execute 位, 把读和执行分开, 检查页是否可执行由硬件来完成, 效率上没有损失.

这三种方法性能代价小, 不需要程序员做任何特殊努力, 组合起来更加有效. 

x86-64被大多数amd和intel所支持,IA32是传统32位

-m64 可以让gcc 产生 x86-64的代码. 





# 第四章 处理器体系结构



## 4.4

现代处理器用了15或更多阶段的流水线, 









## 4.5



数据冒险:

暂停

转发

load/use 冒险不能只转发, 还是需要暂停一下,这叫load interlock



### 4.5.9

三个异常, 

1. halt 
2. 由非法指令和功能码组合
3. 访问非法地址.

 怎么中断指令流是很challenging的.

要求 异常指令后所有指令都不能影响系统状态.

多个异常同时出现

基本原则: 流水线中最深的指令发生的异常, 优先级最高.

### 4.5.13

多周期指令

浮点加法3或4个周期, 整数除法32个周期,我们需要额外的硬件来执行这些计算,还需要让流水线能协调.

如果逗留的话会让fetch和decode 暂停,影响性能.

一条指令进入译码阶段,    可以发射到特殊单元 ,



一个经典的处理器有两个L1 cache, 一个是icache 一个 dcache.

cache miss的时候, 流水线会简单暂停, 完全硬件处理短时间的cache miss

page fault 缺页的时候, 是硬件产生page fault 异常信号, 然后处理器调用操作系统的异常处理代码, 然后发起磁盘到主存的传送操作.完成后, 操作系统会返回原来的程序, 导致缺页的指令会重新执行. 这就是用异常处理来处理长时间的缺页(几百万个时钟周期)



硬件设计人员必须非常谨慎小心, 要仔细分析各种指令类型, 用系统的模拟 测试程序彻底测试.





## 第五章 优化程序性能

 编译器优化, 要考虑指针指向存储器中同一个位置的情况.

327页 
5。14。1
程序剖析是研究运行时间， unix的gprof 可以用来剖析 profiling程序。对于运行时间少于1秒的程序来说， 得到的数字不精确， 如果运行时间比较长还是比较精确的。
gcc －pg然后 gprof prog 可以看到函数调用的历史
剖析可以把一个3分钟的时间降低到一秒以下。 

即使我们把60%的部分提高到不需要任何时间， 也就1/0。4 = 2。5 
所以我们应该 提高系统更多部分的速度， 而不是对着一个地方优化很多。 
在循环中， 有一个变量存储结果 而不是 存了再取会有难以想象的加速，可以快好几倍。
\## 5。5 有时候为了速度， 经常必须要损害一些模块性和抽象性， 比如把get element 改为数组直接访问不检查越界

## 第六章

6。3。2
系统中处处有缓存， 寄存器， tlb， cache，虚拟存储器， 磁盘缓存， 网络缓存（network file system nfs， 客户）， 浏览器缓存， web缓存（代理服务器）

\### cache友好的代码编写
一是常见的情况下运行的快， 
二 是让每个循环内部cache miss数量最小。
三， 

## 第7章
声明为 static 的全局变量或者函数是模块私有的，不能被其他模块访问。 尽可能用static 来保护变量和函数。

###  unix 链接器

强符号， 弱符号， 
不允许多个强符号， 多个弱符号随机选择一个。 未初始化的全局变量是弱符号。 
静态库 从左到右解析， 如果定义符号的库在另一个引用符号的目标文件之前就有可能失败。 

### 7。9 加载可执行文件

loading： 把代码和数据拷贝到内存中， 然后跳转到 entry point 
代码段总是从 0x08048000 开始， 数据段是 。data 。bss 后接下来4kb对齐的地方， malloc向上， 用户栈从最大的合法用户地址开始， 向下增长， 栈上面是给内核保留。 
\####加载器
unix系统中， 父进程生成一个子进程， 子进程 通过exec 系统调用 启动加载器，  加载器删除子进程现有的虚拟存储器段， 创建一组新的代码， 数据，堆和栈段。 通过将虚拟地址空间中的页映射到可执行文件的页大小的片chunk， 新的代码和数据段被初始化为 可执行文件的内容， 加载过程中没有从磁盘到内存的数据拷贝， 直到cpu引用一个被映射到虚拟页才会进行拷贝

### 7。11 在application中加载和链接共享库

linux系统dlopen函数，

与位置无关的代码 pic，position－independent code
被编译为 pic 的共享库可以加载到任何地方， 也可以运行时被多个进程共享。



## 第八章 异常控制流





































































































































