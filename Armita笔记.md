# 笔记

这篇论文讲述了, 他们引入了一个模型, 通过hdl代码 来跟踪信息流Information Flow Tracking

然后, 开发了一个eda tool  名字叫clepsydra, 可以自动生成根据时序流和通用逻辑流的电路

视频会议:

Good evening  Prof,

This is Juyi. I glad to see you. 

## abstract

边信道安全攻击的出现挑战了有关哪些数据可公开获得的经典假设。 对通过测量硬件设计完成时间而收集到的信息进行统计分析可以揭示机密信息。 即使可以轻松利用基于定时的边信道泄漏来破坏数据隐私，但常规的硬件验证工具仍不适合评估这些漏洞。 

为了使硬件设计过程熟悉正式的安全评估，我们引入了一个模型，用于**通过HDL代码跟踪基于时序的信息流**。 基于此模型，我们开发了Clepsydra，这是一种用于自动生成用于**在两个不同通道**(为什么是两个不同通道?)中的硬件设计中跟踪时序流和通用逻辑流的电路的工具。  Clepsydra生成的电路可以通过EDA工具进行分析，以检测时序泄漏(这是什么? 好像就是时序不一样泄露读了哪些数据.  )或正式证明执行时间恒定(啥意思?)。 我们提供有关所提出模型的正确性和准确性的证据，以及使用Clepsydra来验证各种硬件单元（包括加密核心，总线体系结构，缓存和算术模块）的安全性的结果。

## 1.介绍

计算单元生成结果所用时间的变化形成一个泄漏通道，该通道携带有关正在处理的数据的信息。 密码算法的许多实现都显示为基于秘密密钥的布尔值而变化的运行时间。 因此，熟悉基础算法的攻击者可以利用统计方法从定时测量中提取密钥[1]，[2]。 在安全性至关重要的应用中，基于定时的攻击已针对各种硬件单元，例如缓存(这就是学姐的毕业论文)[3]，[4]，共享总线[5]，[6]和浮点运算单元[7]，[8]。 基于定时的侧信道攻击既便宜又普遍pervasive，因此吸引了更多的关注。 它们可以以低成本启动，因为攻击者只需要测量受害者进程的执行时间即可，而无需实际访问设计to the design。 而且，任何包含encompassing依赖于数据的优化的应用程序都容易susceptible受到此类攻击。

防止基于硬件的时序泄漏的大多数方法都依赖于对HDL代码的手动检查，例如，寻找时序变化的来源，例如以秘密值为条件的分支或发送到共享资源的数据相关请求。 这可能是一个漫长而繁琐的任务，并且无法为设计的安全性提供正式保证。 此外，这样的分析仅针对已知的攻击向量检查设计，并且在提供针对所有可能的基于定时的威胁的弹性方面不足。 芯片规模大 ，对设计进行详尽的测试以捕获时序变化也变得不切实际。 随着硬件设计的复杂性和普及性的增长，对安全属性进行自动和形式化分析的需求也在增加。 在过去的十年中，已经提出了多种研究解决方案，以将安全性分析整合到传统的硬件验证工具中。 许多提议的技术[9]，[10]，[11]，[12]使设计人员能够基于信息流跟踪information flow track（IFT）的概念来验证有关机密性，完整性和无干扰性的安全属性。

通过对标记的数据在系统中的移动方式进行建模，IFT工具可以指示敏感信息是否流向设计的任何部分。 但是，由于未指定检测到的流的性质，因此该指示仅限于二进制决策。 更具体地说，IFT技术无法将功能流与基于定时的流分开。 这在许多安全应用中可能会出现问题，因为它们需要通过加密来保护功能流，而定时流则应予以消除。

 例如，在加密核心中，期望从密钥到密文的功能流，而设计者需要确保密文可用的时间不取决于秘密密钥的值。 此外，可能的情况是，不受信任的各方无法直接访问输出，但是其时序足迹是公开的。 例如，即使隐藏输出本身，共享浮点算术单元的完成时间也可以显示有关其输入值的信息。 因此，为了评估有关侧信道攻击的设计安全性，时序流应与功能流区分开。

在这项工作中，我们**展示了如何精确地对时序流进行建模，并介绍了一种IFT技术来捕获硬件设计的时序泄漏**。 我们的模型基于通过检查设计寄存器的接口来检测和传播代码中潜在时序变化的来源。 我们介绍了Clepsydra，它会自动生成跟踪任意HDL代码中的时序流和逻辑流所需的逻辑。 可以通过常规的EDA工具处理由Clepsydra生成的逻辑，以便分析被测设计的时序特性。 由于此逻辑是在静态分析设计中的所有执行路径之后生成的，因此它不依赖于激活设计的最坏情况执行路径来暴露验证期间的时序变化。

在硬件设计流程中很容易采用Clepsydra。 它不使用任何其他HDL语言功能。 尽管它生成可用于运行时检测的可综合逻辑，但我们设想主要在设计时使用EDP工具对Clepsydra逻辑进行分析，以验证基于时序的属性的存在（或不存在).Clepsydra逻辑仅用于分析，在制造之前就被丢弃，因此不增加额外的运行时开销。 我们展示了如何使用Clepsydra来检测各种现有体系结构中的时序泄漏，或证明它们具有恒定的执行时间。 更具体地说，本文提供了以下贡献：

在硬件设计中对基于时序的信息流进行建模； 

 •开发用于自动生成数字逻辑的Clepsydra，以测试硬件设计的时序行为；  

•使用Clepsydra分析各种硬件体系结构的基于时序的安全性。

本文的其余部分安排如下。 第二部分概述了如何将基于IFT的方法用于硬件安全性分析，以及我们旨在如何改进它们。 第三节介绍了我们提出的跟踪时序流的模型。 在第四节中，我们详细介绍了Clepsydra的实现，并在第五节中介绍了**通过使用Clepsydra分析各种体系结构的安全性**而获得的实验结果。我们在第六节中提供了相关工作的简要概述，并在第七节中完成了工作。

## 第二章背景

在本节中，我们将详细介绍基于IFT的技术如何实现安全性分析，并说明为什么当前的工具不足以建立基于时序的属性的正式保证。 我们进一步指出，采用更细致的模型来分离不同形式的逻辑流可以解决此问题。

###    A.安全属性

隔离不同的逻辑组件是硬件设计人员寻求提供的主要安全属性。 可以通过隔离实施两个主要的安全属性

机密性：通过隔离处理机密数据的单元，防止不信任方观察机密信息。 例如，在加密硬件中，我们要确保密钥不会由于设计缺陷，硬件木马或侧通道泄漏而泄漏到公共输出。
   •完整性：防止未授权方修改敏感信息。 例如，存储加密密钥的寄存器只能由可信源访问。
   为了提供可靠的安全保证，必须同时通过数据通道（也称为功能通道）和定时通道来分析信息流。 前者确保数据不会在隔离的组件之间移动，而后者则证明隔离的实体的时序足迹不会形成通信通道。

### B IFT 硬件安全验证

IFT技术提供了一种用于验证与完整性和机密性有关的安全性的系统方法。 通过将安全标签分配给不同的信号并跟踪这些标签在系统中的传播方式来工作。 可以通过定义输入标签并检查输出标签来测试不同的安全属性。IFT技术的精度，即所报告的流量与实际流量的相似程度，直接受到标签传播规则的影响。

如果标签传播规则不够全面，无法捕获所有形式的数字流，则该设计可能会被错误地标记为安全。 信息可以显性和隐性方式流动。 信息以显式形式流向正在处理敏感数据的操作的输出。 更巧妙地，控制条件语句的数据可能会隐式影响结果。 例如，在代码if（c）中，则x = y + z; 信号x受信号y和z显式影响，并受信号c隐式影响。 为了使IFT技术可靠且没有假阴性，它应该能够跟踪隐式和显式流。 

此外，标签传播规则应检测信息流被阻止的情况。 例如，如果秘密数据的某些位与零进行“与”运算，则从这些位到“与”门的输出将没有流量。 但是，将输入的最高安全性标签分配给输出的保守跟踪规则会将所有输出位标记为敏感。 相反，基于更严格规则的精确IFT工具会考虑操作数的布尔值和操作功能，可以识别流量的缺失并避免某些误报[13]。

### C.隔离时序流

现有的IFT技术使用相同的一组标签和传播规则来跟踪功能流和时序流。 因此，当检测到流时，它是功能流还是定时流，仍然是未知的。 但是，不同的应用程序需要不同的隔离形式。 例如，当在互不信任的进程之间共享缓存时，应同时保证**时序和功能隔离**。 但是，加密算法的安全实现只需要消除定时通道，因为功能流受到加密的保护。 无法使用IFT技术测试此属性，该技术会通过一组标签捕获所有形式的逻辑流。 由于密码始终通过功能流受到秘密密钥的影响，因此其安全标签将被提升为密钥的安全标签，而与定时流的存在无关。 这在很大程度上限制了IFT技术在安全性分析方面的应用，因为在许多不可避免的功能流程但应消除基于时序的流程的许多应用中也发生了类似的情况。

 由于常规的IFT技术被设计为跟踪所有形式的逻辑流，因此采用它们来仅检测时序流会导致相当多的误报。 由于**时序流是信息流的子集**； 可以设计一套更严格的传播规则，这些规则可以处理一组单独的标签，并且仅跟踪时序流，而忽略功能性流。 在下一节中，我们介绍一组规则，这些规则仅用于检测时序流并通过系统对其进行跟踪。

## 三， 对时序流进行建模

如果输出可用的时间取决于输入的布尔值，则电路的输入到输出之间存在时序流。 如果导致它们的输入信号包含秘密信息，则可以利用这些流，并且该单元的完成时间可以由不受信任的方来衡量。 例如，考虑如图1所示的除法单元，该除法单元是通过从除数中连续除数来实现的。 该算法的执行时间取决于输入值，因为减法次数不是固定的。 这表明，即使未公开商的布尔值，评估执行时间也会显示有关输入的信息。 在本节中，我们讨论了如何在数字电路中表示时序变化，并开发了捕获它们的正式模型。

### A.表征时序流设计的完成时间

由其输出更新为最终值的时间来定义。 如果从输入X到输出Y不存在任何时序流，则随着X的变化，Y达到其最终值所需的时间应该是恒定的。 因此，为了检测时序流，我们需要确定是否以恒定的时间步长对输出进行更新。 这可以通过检测所有设计变量更新时间的变化并跟踪到最终输出来解决。 我们将通过回答三个问题来讨论如何对任意数字电路实现此目的：一组敏感输入如何产生时序流？ 流一旦生成，将如何传播？ 最后，阻止时序信息流并强制执行恒定时间的必要条件是什么？ 由于我们有兴趣检测时钟周期方面的时序变化，因此我们需要分析设计的寄存器和控制它们的信号。

时序变化的产生：设计的寄存器由一组数据信号写入，这些信号在每个周期由控制器进行多路复用。 考虑一个没有任何数据或控制权的寄存器

信号具有时序变化，但可能包含敏感数据，我们想弄清在寄存器输出处出现时序变化的情况。 如果肯定在每个时钟周期更新寄存器，则不会有时序变化。 然而，如果更新的发生是暂时的，即寄存器具有保持其当前值或获得新值的自由度，则可能发生时序变化。 如果决定更新是否发生的控制器信号是敏感的，则所产生的时序变化也将包含敏感信息。 回到图1中的除法示例，对寄存器temp_quotient的更新以输入为条件。 因此，基于输入信号的布尔值，该寄存器可能在不同时间获得其最终值。 在定理1和定理2中，我们表明检测由敏感数据引起的条件更新可以合理地捕获所有时序流，同时丢弃仅用于功能的时序流。

时序变化的传播和阻塞：如果寄存器的任何数据或控制信号都具有周期电平变化，则该变化可以流经寄存器。 尽管简单地传播这些流会合理地暴露所有时序变化，但是当实施缓解技术以消除变化时，它会高估该流。 换句话说，我们需要能够检测到即使寄存器输入存在时序变化也无法观察到时序变化的情况。从（a）我们可以推断出迹线B的值在时间tn处从vn-1更新为vn，而等式（b）表明迹线B的值在时间tn处没有更新，等于vn-1 根据定义4，所有输入事件保持相同∀i/∈I，这意味着它们之间的唯一区别是敏感输入。 因此，输出更新的差异是由一组敏感输入引起的，并由Ft根据定义10捕获。
  定理2. FSM F的时间跟踪逻辑Ft不能捕获FSM的仅功能流。

在图1的除法示例中，不是直接将temp_quotient写到输出，而是在更新输出值之前需要一个等待时间。 如果等待时间长于最坏情况的执行时间，则输出将以固定的时间步长进行更新。 我们将在定理3中证明，如果存在一个完全控制寄存器更新发生的非敏感控制信号，它将阻止从寄存器的输入到输出的时序变化流。 完全控制控制信号意味着当且仅当控制器获得新值时，寄存器才获得新值。 因此，寄存器输出的时序签名与控制信号相同（具有单个周期延迟），并且独立于其输入。 实施此策略会在一定程度上减少误报的数量，而不会强加任何误报。在除法示例中，如果计数器足够大，则输出值在完成条件更新后立即更改，并在完成不更改时保持其旧值。 因此，最终输出的所有变化都由完成信号控制，该完成信号不敏感，表明持续执行.

### B 理论和证明

我们证明了我们的模型通过证明检测设计寄存器的暂定更新足以暴露所有时序变化，并且通过不敏感的完全控制信号消除了现有的时序变化，从而合理地发现了所有潜在的时序通道。 我们还证明了我们的模型忽略了仅功能流，因此与捕获所有逻辑流的IFT技术相比，它更精确地分析了基于时序的属性。

定义1.数据集Y和时间值T上的事件e对于y∈Y和t∈T表示为元组e =（y，t），其中y和t可以通过函数val（e）和time检索 （e）。 如果y是n维向量，并且t过去的时钟滴答数是多少，则具有n个端口的设计的输入或输出可以用事件e表示。

 定义2.迹线A（Y，n）表示n个事件{ei} n集Y，它们按时间排序：time（ei）= time（ei + 1）+ 1。
   在数据定义3上，i = 1。对于任何迹线A（Y，n），其不同的迹线d（A）被定义为A的最长子迹线，其中连续事件具有不同的值，并且对于任何两个连续事件 在val（ei）= val（ei-1）的A中，ei在d（A）中。
   例如，对于迹线A = {（10，1），（10，2），（20，3），（20，4）}，其唯一迹线为d（A）= {（10，1），（  20，3）}，因为这些值仅在时钟周期1和3发生变化。

定义4.如果迹线A（X，k）和A（X，k）的对应事件ei和e之间唯一的差为j∈I，则迹线A（X，k）对于值I保持值。在IFT分析中，我们感兴趣 通过针对仅在敏感输入中有所不同的输入迹线测试设计，从而对一组敏感变量的效果产生影响。 可以通过使用值保留跟踪来建模此想法，其中I是敏感输入的集合。
   定义5. FSM的输出完全由输入J控制，只要且仅当输入J更新时，FSM输出才更新。
   定义6.对于任何一组电线W，灵敏度标签组Ws和时序标签组Wt分别表示W是否携带敏感信息或时序变化。 定义7.在由FSM F =（X，Y，S，s0，δ，α）表示的时序电路中，如果存在两个值保留（相对于 I）输入迹线A（X，k）和A（X，k）使得当馈入FSM时，输出的不同迹线的时间步是等效的，而相应事件的值却有所不同

定义8.在由FSM F =（X，Y，S，s0，δ，α）表示的时序电路中，如果存在两个保持值（相对于I）的输入，则存在来自一组敏感输入I的时序流 迹线A（X，k）和A（X，k），使得当馈送到FSM时，输出的不同迹线的时间步长是不相等的。 正式表示，如果B =α（A，s0）且B=α（A，s0），则：

定义9.对于组合逻辑函数f：X→Y，其流量跟踪函数fs：X×Xs→Ys确定敏感输入是否影响输出。 如果f（x1，...，xn）=（y1，...，ym），则fs（x1，...，xn，x1）敏感输入{xj | xjs = 1表示信息从敏感输入流向 输出yi。
   定义10.对于顺序逻辑函数f：X×S→Y，其中X，S，Y为输入，状态和输出，时间跟踪函数ft：X×Xs×Xt×S×Ss×St→  Yt确定受敏感信息或时序变化污染的一组输入是否会影响输出的时序变化。 如果f（x1，x2，...，xn，s1，s2，...，sl）=（y1，y2，...，ym），则ft（x1，...，xn，x1s sls，s1t  ，...，slt）=（y1t {xj | xjs，...，xns，x1t，...，xnt，s1，...，sl，s1s，...，，...，ymt）  ，如果一组受污染的输入∨xjt = 1}会影响状态si是否更新，则sit = 1，我们说从受污染的输入到输出si的时序流存在。

 定理1. FSM F的时间跟踪逻辑Ft捕获FSM的时序流。

根据定义4，所有输入事件保持相同∀i/∈I，这意味着它们之间的唯一区别是敏感输入。 因此，输出更新的差异是由一组敏感输入引起的，并由Ft根据定义10捕获。
  定理2. FSM F的时间跟踪逻辑Ft不能捕获FSM的仅功能流。

证明。 我们通过证明仅功能流的存在不会对输出更新的发生施加任何变化，因此不会被Ft捕获，从而证明了该定理。 如果关于敏感输入I的集合存在纯功能流，则基于定义7，存在值保留迹线A（X，k），A（X，k）使得：如果B =α（A  ），d（B）=（e1，e2，...，em）和B=α（A），d（B）=（e1，e2，...，em  ）然后：i）（1）∀i∈[1：m]：time（ei）= time（e（2）∃j∈[1：m]：使得val（ej）= val（e  j）我们声称不存在时间tn使得其中一条迹线的值被更新而另一条迹线不被更新，在不失一般性的情况下，我们表明没有时间tn处的B的值被更新，而B的值却被更新。  B的值保持不变，我们通过矛盾证明证明这一点：

矛盾假设：在时间tn时，迹线B被更新，而迹线B保持其值。

定理3。如果FSM F完全受输入J的控制，使得J /∈I，那么FSM F的输出上就不会观察到时序变化，这是因为处理了迹线，该迹线相对于集合I保持了值。
   证明。 我们将通过矛盾证明来证明该定理。 矛盾假设：存在值保留（相对于I）的迹线A（X，k）和A（X，k），这些迹线在FSM F的输出上施加了时序流，该流由输入J /∈I完全控制。 根据定义8：

上面的等式指定了在时间tn迹线B已经被更新，而B没有被更新。

 让我们分别用迹线A和A分别表示迹线A和A的完全控制输入J的子迹线。 基于定义5，等式（a）指示输入j在时间tn处被更新，并且从（b）我们知道输入j此时不被更新。 这是一个矛盾，因为输入迹线A和A之间的唯一区别是相对于集合I，并且由于J /∈I，因此j和j应该相同。

图 2 :clepsydra铜壶滴漏 overview

输入: verilog代码的抽象语法树文件, IFT 库(用verilog写)

输出:IFT 增强的 verilog 代码,  

clepsydra是用python写的,可以插入logic ,为了tracking 敏感信息. 插入逻辑为了tracking 敏感时序变量





## 四描述细节

我们描述了Clepsydra的实现细节。如图2所示，Clepsydra的输入是由其抽象语法树abstract syntax tree（AST）描述的硬件设计，该语法树是通过解析其HDL表示而获得的。 作为输出，Clepsydra生成可综合的Verilog代码，该代码具有原始设计中指定的所有功能，以及用于传播从设计输入到其输出的基于时序和通用信息流的互补逻辑。

 跟踪逻辑分两个步骤实现：1）用标签灵敏度级别和时序级别扩展设计中的每个变量，标签灵敏度级别和时序级别分别指示该变量是否携带敏感信息或时序变化；  

2）插入逻辑，以在这些标签的相应变量更改时更新这些标签。 然后将Clepsydra生成的代码提供给EDA工具进行安全性分析。 通过指定输入变量的标签并在模拟，形式验证或仿真之后观察输出标签来评估安全性。 如果输出标签符合设计者的意图，则跟踪逻辑将被丢弃，原始设计可用于制造。 如果违反安全性，应修改原始设计，将其输入给Clepsydra，然后重新测试.

  借助Clepsydra，可以针对标记为敏感的任意输入子集来分析设计的时序行为。 这有助于对各种安全属性进行建模。 例如，可以通过将所有输入标记为敏感来测试恒定时间执行。 但是在许多情况下，我们只对某些输入的持续执行时间感兴趣。 例如，当在互不信任的进程之间共享缓存时，可以利用由于访问敏感数据而导致的时序变化。 但是，由于非敏感数据上的缓存冲突而导致的变化对对手而言并不有价值。 不加选择地消除所有时序变化会导致整个缓存失效。 此外，许多缓解技术都基于随机化时序变化。 为了区分良性变异与敏感变异，我们应检查变异的来源。 这是通过跟踪整个电路中的敏感数据并从中提取敏感时序变化来完成的。

### A.跟踪敏感信息

敏感信息会通过数据路径和控制路径影响计算结果，从而创建显式和隐式流。为了检测显式流，Clepsydra用IFT增强版本替换了每个数据路径操作，该版本可以在预先设计的IFT库中作为Verilog模块使用（算法1的11-13行）。 每个IFT增强操作都会接收到该操作的原始输入以及它们的灵敏度标签，并计算该运算的输出以及它们的灵敏度标签。 图3的第一行显示了一个用IFT增强模块替换加操作的简单示例。可以通过修改IFT增强模块的标签传播规则来探索跟踪逻辑的各种复杂度-精度折衷方案。  [13 ]。 为了跟踪赋值是否受到敏感数据的隐式影响，我们需要确定其执行是否依赖于任何敏感变量。 为此，Clepsydra从其AST表示中提取了设计的控制流程图，并为每个条件分配构造了一个控制信号列表（算法1的第68行）。 接下来，基于列表中的变量及其敏感度标签，将生成用于跟踪隐式流的逻辑，并将其添加到显式流跟踪逻辑中（算法1的第18-20行）。

### B.跟踪时序流

Clepsydra在每个寄存器接口插入逻辑组件，以检测是否从敏感数据中产生了任何时序变化，以及从寄存器输入流到寄存器输出是否存在现有的变化（算法1的第21-22行）。 正如我们之前所证明的，形成时序变化的必要条件是是否存在更新取决于敏感值的寄存器。 为了识别这些情况，我们需要确定寄存器是否具有在获取新值和保持其当前值之间进行选择的灵活性。 为了检查设计中每个寄存器的该属性，Clepsydra静态枚举了该寄存器写入的所有路径，并将其与该寄存器的控制器理论上可以激活的路径总数进行比较。 如果这两个数字不相等，则设置一个指示寄存器更新为暂定的位（算法1的1-5行）。 与软件语言相比，对Verilog代码的这种分析相对容易，因为对寄存器的多次写入被建模为具有n个数据输入和m个控制输入的单个多路复用器。 如果n= 2m，则表示出现临时更新方案，这表明多路复用器已从其输出直接反馈到其自己的输入。 为了说明这个想法，请考虑图3（a）中编写的Verilog代码和图3（b）中由Clepsydra生成的IFT增强的Verilog代码。 第9行和第20行中突出显示的部分显示了负责检测时序流生成的逻辑。  

A_bal和Y_bal的值由Clepsydra在分析原始代码中的分支后静态确定。 还添加了XNOR函数，以检测其中寄存器从其他变量获取其值而不实际更新的情况。 即使这种情况在实际设计中很少见，但仍会添加用于检测它们的逻辑，以确保捕获通过重命名变量掩盖临时更新的情况。

​    时序变化一旦生成，就直接流过后续寄存器，除非实现了消除变化的特殊机制。 图3中的寄存器X直接从寄存器A获取其值，因此，如果存在任何时序变化作为A的输出，它将无条件地流到X。如图3（b）的第二行所示，时序变化直接流动 通过组合逻辑，因为我们对循环级精度感兴趣。 正如我们在上一节中所证明的，如果存在任何不敏感的控制信号完全控制寄存器的更新，则它可能会阻塞时序信息的流动。 为了检测是否存在用于条件分配给寄存器的完全控制信号，Clepsydra插入了XOR门来比较更新的发生。 在图3（b）的线11和22中示出了该逻辑。  XOR功能表示输出寄存器及其控制器的更新是同步的。 逆变器指定控制器执行没有任何敏感信息。 如AND函数所示，此逻辑负责防止在某种程度上高估流量。 为简单起见，图中未显示Y_up，A_up，B_up和done_up背后的逻辑，但它们是通过将当前状态与下一个状态进行XOR运算而得出的。 由于对控制信号的更新可以在寄存器输出端观察到一个周期的延迟，因此，Clepsydra插入了缓冲区以存储来自前一个周期的控制值，以便计算它们是否已在前一个周期中被更新（第16-17行） 算法1）。

##  五，实验结果

在本节中，我们将详细说明如何基于IFT概念指定各种安全属性，并在Clepsydra逻辑上进行验证。 表I列出了我们测试的硬件设计以及评估的安全性。 对于每种设计，我们简要讨论创建时序通道的体系结构功能，用于利用时序通道的攻击模型，现有的缓解技术以及我们的安全性分析结果。 对于我们所有的实验，我们通过使用Yosis工具[14]对其进行解析来获得普通Verilog代码的AST表示，并使用Clepsydra生成跟踪逻辑。 在Clepsydra生成的IFT增强代码上，可以通过将输入信号X_s设置为高电平，并在模拟或形式验证之后观察输出Y_t的值，来检查输入X对输出Y的定时行为的影响。

### A.算术模块







对于第一组实验，我们寻求证明算术单元的恒定时间特性，因为可以利用这些单元的完成时间变化来提取有关输入的信息[8]，[7]。 我们从Opencores网站[15]测试了一个定点数学库，该库应该按照其设计者的要求在恒定时间内运行。 为了验证这一说法，我们将每个单元的数据输入标记为敏感，并观察了输出的时序标签。 乘法单元基于每个循环的部分乘积。 因此，如果乘法器的MSB位为零，则由于最后一个周期中的部分积为零，因此可以更快地获得结果。 计数器达到零后，设置设计的输出就绪信号。 在分析了该设计之后，我们注意到尽管就绪输出没有时序变化，但产品结果却并非如此。 这表明结果可能潜在地可用

在发出就绪信号之前。 为了消除这种流程，我们通过添加一个寄存器来修改设计，该寄存器阻止工作结果在计数器复位之前写入最终输出。 进行此修改后，我们可以使用Questa形式验证工具正式证明设计能够在恒定时间内运行。 类似于我们整篇文章中的示例，除法单元是通过随后从股息中减去除数来实现的。 与乘法单元类似，等待状态负责在最终输出上强制执行恒定时间更新。 这次我们的分析未检测到任何时序变化，因为所有输出变量（包括结果本身）均由等待状态控制。 这组实验表明，我们的模型能够隔离不同形式的流程，并证明存在功能性流程时不存在时序流程。 此外，它表明所生成的跟踪逻辑足够精确，足以检测出只要延迟最坏情况的情况，就可以通过延迟所有更新来消除时序变化的情况。(就把所有的都延迟到最后更新就外部看不出来 ,但是我很怀疑这样真的有用吗, 造出了一个电路慢一些, 你说安全, 但是大部分人用不到安全.)

### B.缓存实现

基于缓存的边信道攻击已被反复采用，破坏了诸如RSA和AES之类的密码的软件实现。 这些攻击针对使用预先计算的值的实现，这些预先计算的值存储在缓存中，并根据密钥的值进行访问。 因此，能够提取运行加密的进程的缓存访问模式的攻击者可以推断出与密钥有关的信息(时间不同就可以知道哪些数据)。  Percival [4]表明，与RSA密码的OpenSSL实现共享缓存的对抗过程可以通过在缓存中引发冲突来获取受害者进程的缓存访问模式。 通过远程攻击OpenSSL协议的AES实现，Bernstein [3]表明，即使不与不受信任的进程共享缓存，也可以利用定时通道。

 在攻击中，伯恩斯坦利用受害者进程本身利用不同请求之间的缓存冲突来揭示加密密钥。 尽管这些攻击的实现方式有很大不同，但它们都利用了缓存冲突带来的时间变化。 已经提出了几种高速缓存设计来限制敏感访问的索引值，以影响高速缓存在以后的周期中检索数据所花费的时间。我们已经使用Clepsydra来检查不安全缓存中的时序流，以及在[16]中引入的两种安全体系结构PLcache和RPcache。

 为了通过外部干扰对时序泄漏进行建模，我们考虑了两个具有隔离的地址空间的进程，它们共享同一高速缓存。 将一个进程进行的访问标记为敏感，我们希望确定另一进程读取的数据是否包含时序变化。内部干扰场景是通过单个过程建模的，并且当使用不同标签读取同一行时，检查将某些索引标记为敏感是否会导致时序变化。  **PLcache通过让进程将其数据锁定在缓存中并禁用其驱逐来消除泄漏通道**。 由于敏感数据不能再被驱逐，因此它不会影响系统的时序签名。 我们实现了PLcache，并从Clepsydra获取了其IFTenhanced跟踪逻辑，以测试该分区方案是否消除了流量。 根据我们的分析，如果将具有敏感索引的数据预加载到缓存并锁定，则不会由于以后访问锁定行而导致信息泄漏。 但是，此结果基于以下假设：预加载阶段本身并不敏感。 

接下来，我们测试了RPcache，**它随机排列内存到缓存地址的映射**，**以消除冲突之间的任何可利用的关系**。 当检测到不信任进程之间的外部干扰时，PRcache会随机选择一个缓存行进行驱逐。 因此，攻击者无法驱逐受害者的过程敏感信息，也无法观察到这是否会导致延迟。 在内部干扰的情况下，可通过将冲突访问中的数据直接发送到处理器并随机逐出另一条线路来处理冲突。 我们的分析表明，假设对随机数生成器的输入不敏感，RPcache可以消除时序变化。

### C.总线体系结构

当不同的单元通过共享总线连接时，硬件设计中定时通道的另一个来源就会出现。 在这种情况下，应该隔离的核心可以通过调制对共享资源的访问模式并影响其他核心可以使用相同资源的时间来秘密进行通信。 使用Clepsydra，我们检查了WISHBONE互连体系结构用于仲裁SoC上的访问时时序流的存在。 为了通过WISHBONE访问共享资源，主内核发送请求信号，并等待仲裁器发回ack信号。 可以通过将一个内核发送的请求信号标记为敏感信号，并在以后的请求中观察发送给另一内核的ack信号的时序标签，来评估不同内核之间的时序通道。 我们已经针对原始的WISHBONE仲裁器及其两个修改版本测试了此方案。

取决于以前发送给仲裁员的请求。 为了消除信道，我们用TDMA方案替换了循环仲裁器，并重新测试了设计。 在这种情况下，由于基于计数器给出了授权，因此未检测到任何定时信道。 为了提高仲裁程序的效率，我们测试了一种更灵活的方案，其中将内核分为两个不同的组。 同一组中的内核根据循环算法进行仲裁，而这两组是时分多路复用的。 这次我们的实验表明，两组之间是相互隔离的，而同一组元素之间存在定时通道。

### D.加密核心

最后，我们测试了RSA和AES密码的硬件实现中的时序变化。 由于密文是根据密钥计算的，因此从密钥到密文的功能流程是不可避免的。 因此，不能利用现有的IFT工具来检查设计人员不打算使用的定时通道。 在这里，我们已经从Trusthub基准[18]中以两种密码测试了定时信道的存在。 我们通过将密钥位标记为敏感并观察输出的时序标签来评估从秘密密钥到密文的时序流。 使用Questa形式验证工具，我们可以证明AES内核可以持续运行。 但是，对于RSA内核，由于模幂运算步骤的执行不安全，因此检测到了从秘密密钥到密码的时序流。 我们将比较不同RSA架构的时序泄漏和所提出的缓解技术的有效性作为我们未来的工作。

## 六 相关工作

在过去的十年中，开发了多种工具来跟踪通过硬件设计的信息流。  Tiwari等人[12]实现了一个微处理器，该微处理器通过为每个门添加的影子逻辑动态跟踪信息流。 由于在功率，面积和性能方面的巨大开销，在设计期间，门级信息流跟踪（GLIFT）已主要用于测试和验证[19]。  Oberg等人[20]证明，在门级插入阴影逻辑可以检测所有信息流，包括时序和功能流。 在更高的抽象级别上，已引入了多种安全的HDL语言，以支持设计可证明的安全硬件。  Caisson [21]和Sapper [22]都是基于FSM的语言，使用类型系统进行了扩展。 设计人员使用这些语言为每个变量定义一个安全标签，并通过控制状态之间的事务来限制信息流。  SecVerilog [9]在Verilog语言中添加了一种类型系统，以表示不同的安全级别。  SecVerilog用户需要根据他们希望强制执行的属性为设计中的每个变量定义一种类型。  SecVerilog类型系统静态验证用户定义的类型和IFT属性是否符合。 尽管这些工具有助于安全的硬件设计，但它们需要使用新的语言重新设计硬件。  VeriCoq [23]自动将HDL代码传输到Coq表示形式，其中可以在带注释的代码上测试安全属性。 尽管所有这些方法通过将每个信号的标签提高到其前任信号的最高标签来采用保守的跟踪规则，但RTLIFT [11]允许更灵活的流跟踪规则。 根据用户指定的精度级别，RTLIFT会为被测设计生成流跟踪逻辑，该逻辑可用于分析不同的安全属性。 如前所述，所有提到的IFT工具都跟踪通过单个通道的所有逻辑信息流，而未指定检测到的流的性质。 在这项工作中，我们提出了一种在两个单独的位置中跟踪时序流和通用信息流的方法

## 七 结论

在这项工作中，我们提出了一个用于在硬件设计中跟踪基于时序的信息流的模型。 我们正式证明，我们的模型能够很好地捕获所有时序变化，并将时序流与逻辑流精确分离。 我们引入了IFT工具Clepsydra，该工具会根据提出的模型自动生成跟踪逻辑.

 Clepsydra通过使用可合成的逻辑增强普通的HDL代码来促进硬件安全性验证，可使用常规EDA工具在其上测试各种安全性。 在我们的实验中，我们利用Clepsydra来检测不同体系结构中的定时通道，并证明了在采用缓解技术（如随机化，分区或延迟到最坏情况下执行）时，没有时序泄漏。

参考论文13 讲了论文综合的优化,  有具体的电路图,  

